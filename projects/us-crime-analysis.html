---
---
<!DOCTYPE html>
<html lang="en">
	<head>
		<link rel="icon" type="image/png" sizes="32x32" href="../favicons/favicon.png">
		<link rel="icon" type="image/png" sizes="16x16" href="../favicons/favicon.png">
		<meta name="theme-color" content="#ffffff">

		<script>
			window.dataLayer = window.dataLayer || [];
		  	function gtag(){dataLayer.push(arguments);}
		  	gtag('js', new Date());
		  	gtag('config', 'UA-110543961-1');
		</script>

        <meta name="viewport" content="width=device-width, initial-scale=1.0">

		<meta name="description" content="Anthony Do - Portfolio; Machine Learning, Data Analysis">
		<meta name="keywords" content="Machine Learning, Data Analysis">
		<meta name="author" content="Anthony Do">

		<title>Anthony Do</title>

		<link href="../css/bootstrap.min.css" rel="stylesheet">
		<link href="../css/styles.css" rel="stylesheet">

		<script src="https://code.jquery.com/jquery-latest.js" type="text/javascript"></script>
		<script src="../js/jquery.isotope.js" type="text/javascript"></script>
		<script src="../js/filter.js" type="text/javascript"></script>
		<script src="../js/bootstrap.bundle.min.js"></script>
        <script src="../js/template.js" type="text/javascript" defer></script>

        <link rel="stylesheet" href="../css/code-highlight.css">
        <script src="../js/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
		{% seo %}
	</head>

  	<body>

        <span class="side-btn" id="sideBtn" onclick="toggleNav()">ùêì</span>

        <div class="topnav">
			<portfolio-nav></portfolio-nav>
		</div>
        
        <nav id="mySidenav" class="section-nav">
            <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
            <li class="toc">Table of Contents</li>

            <hr style="color: white; border-top: 3px solid white;">

            <ol>
                <li><a href="#section-1">Overview</a></li>
                <li><a href="#section-2">Exploratory Data Analysis</a></li>
                <li><a href="#section-3">Machine Learning Algorithms</a>
                    <ul>
                        <li><a href="#section-4">Principal Component</a></li>
                        <li><a href="#section-5">K-Means Clustering</a></li>
                        <li><a href="#section-6">Hierarchical Clustering</a></li>
                        <li><a href="#section-7">DBSCAN</a></li>
                    </ul>
                </li>
            </ol>
        </nav>

		<div class="container">

			<br>
			<br>
			<br>

        <section id="section-1">

            <h1 id="us-crime-analysis"><b>US Crime Analysis</b></h1>

            <hr>

            <p>There are many crimes that happen in the United States. Some believe that bigger cities and more populated states have more crime rates. In this project, we will be analyzing a dataset describing 1973 violent crime rates by US State. The crimes considered are assault, murder, and rape. Also included is the percentage of the population living in urban areas. Our goal is to use unsupervised machine learning methods such as Cluster Heat Maps, Principal Component Analysis, K-Means Clustering, Hierarchical Clustering, and DBSCAN to understand how violent crimes differ between states. </p>
            
            <br>

            <h4 id="resources"><b>Resources</b></h4>

            <ul>
                <li>Software: Python 3.10, Jupyter Lab 3.4.4</li>
                <li>Data Source: USArrests.csv
            </ul>

        </section>

        <br>

        <section id="section-2">

            <h2 id="preliminary-exploratory-analysis"><b>Exploratory Data Analysis</b></h2>

            <hr>

            <p>The dataset is available as <em>USarrests.csv</em>. The dataset has 50 observations (corresponding to each state) on 4 variables: </p>

            <ol>
                <li>Murder: Murder arrests (per 100,000 residents)</li>
                <li>Assault: Assault arrests (per 100,000 residents)</li>
                <li>UrbanPop: Percent urban population</li>
                <li>Rape: Rape arrests (per 100,000 residents)</li>
            </ol>

            <p>You can read more about the dataset <a href="https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/USArrests.html">here</a>. </p>

            <br>

            <img src="https://user-images.githubusercontent.com/29410712/179429045-7476b1c1-fe80-45de-92e9-4531dd56e933.png" alt="us-crime-scatter" class="center">

            <br>

            <p>In our preliminary analysis, we can see that Murder and Assault are highly positively correlated with a correlation of 0.8. There are some correlations between Rape + Assault and Rape + Murder but not as strong. There is almost no correlation between the Urban Population with Murder and Assault.</p>
            
            <br>
            
            <h4 id="analysis-with-cluster-heat-map"><b>Analysis with Cluster Heat Map</b></h4>

            <img src="https://user-images.githubusercontent.com/29410712/179429129-f9b3fb27-773f-4f4b-b320-ffd95f49144c.png" alt="us-crime-heat">

            <p>In our cluster heat map analysis, we can visualize that Urban Population does not necessarily correlate with Murder and Assault. This means that states with a higher population do not determine murders or assaults. There is some relationship between the number of Rapes, Murders, and Assaults. We can also see that Murder and Assault are similar within the states.</p>
            
        </section>

        <br>

        <section id="section-3">
            
            <h2 id="deeper-analysis"><b>Machine Learning Algorithms</b></h2>

            <hr>

        <section id="section-4">

            <h4 id="visualizing-data-using-principal-component-analysis-pca-"><b>Principal Component Analysis (PCA)</b></h4>

            <p>Principal Component Analysis (PCA) is one of the most used unsupervised machine learning algorithms across a variety of applications: exploratory data analysis, dimensionality reduction, information compression, and data de-noising. PCA is a dimensionality reduction technique that transforms a set of features in a dataset into a smaller number of features called principal components while at the same time trying to retain as much information in the original dataset as possible. Since we have 4 different variables, we have a fourth-dimensional data set. PCA can take 4 or more variables and make a two-dimensional PCA plot. PCA can also tell us which variable is the most valuable for clustering the data. It also can tell us how accurate the two-dimensional graph is. </p>
            <p>Principal Component Analysis calculates the average of each variable and using this average, finds the center of the data. It then shifts the data so that the center of the data is at the origin. From here, we input principal components. The principal components are vectors, but they are not chosen at random. The first principal component (PC1) is computed so that it explains the greatest amount of variance in the original features. Thus, it minimizes the distance between each data point on the graph (Sum of Squared) so PC1 is a linear combination of variables. It uses a scaled vector called the &quot;Eigenvector&quot; or &quot;Singular Vector&quot; for PC1. The sum of squared distances for the best fit line is the Eigenvalue for PC1. The second component (PC2) is orthogonal to the first, and it explains the greatest amount of variance left after the first principal component. Then we find PC3 and PC4 which are perpendicular to PC1 and PC2 that goes through the origin. The number of PCs is either the number of variables or the number of samples, whichever is smaller. </p>
            
            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
# PCA Model
pca_model = PCA()
X_PCA = pca_model.fit_transform(X)
df_plot = pd.DataFrame(X_PCA, columns=['PC1', 'PC2', 'PC3', 'PC4'])
df_plot.head()
fig,ax1 = plt.subplots()

ax1.set_xlim(X_PCA[:,0].min()-1,X_PCA[:,0].max()+1)
ax1.set_ylim(X_PCA[:,1].min()-1,X_PCA[:,1].max()+1)

# Recenters Data
for i,name in enumerate(df['Unnamed: 0'].values):
    ax1.annotate(name, (X_PCA[i,0], X_PCA[i,1]), ha='center',fontsize=10)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/179429289-cff10be1-9fed-4382-9dda-fd1a933c8f3c.png" alt="pca" class="center">

            <p>Once all the principal components are figured out, you can use the eigenvalues to determine the proportion of variation that each PC accounts for. Then you can create a scree plot which is a graphical representation of the percentages of variation that each PC accounts for.</p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
# Scree Plot
var_ratio = pca_model.explained_variance_ratio_
plt.plot([1,2,3,4], var_ratio, '-o')
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/179429298-ec5602ad-dd69-4ee8-bedc-c08b68909080.png" alt="scree-plot" class="center">

            <p>In this scree plot, we can see that PC1, PC2, and PC3 account for the vast majority of the variation. This means that a three-dimensional graph, using just PC1, PC2, and PC3 would be a good approximation of this four-dimensional graph since it would account for 95.66% of the variation in the data. Also, a two-dimensional graph would account for 86.76% of the variation in the data.</p>
            
        </section>

        <br>

        <section id="section-5">
            
            <h4 id="k-means-cluster-analysis"><b>K-Means Cluster Analysis</b></b></h4>

            <p>We will now cluster the states into four clusters using k-means. K-means cluster identifies initial clusters and calculates the variances between each cluster or the Euclidean distance. It clusters all the remaining points, calculates the mean of each cluster, and then reclusters based on the new means. It repeats until the clusters no longer change. It restarts the cluster until it finds the best overall cluster. It does as much reclustering as we tell it to do. It then comes back and returns to the optimal one.</p>
            
            <br>
            <br>

            <img src="https://user-images.githubusercontent.com/29410712/179429370-8d082b0d-4f10-47bf-8953-4f33f2a54cd2.png" alt="different-k-mean" class="center">

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
kmeans = KMeans(n_clusters=4)
kmeans.fit(X)
y_kmeans = kmeans.predict(X)
fig,ax1 = plt.subplots()

plt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50)

for i,name in enumerate(df['Unnamed: 0'].values):
    ax1.annotate(name, (X[i,0], X[i,1]), ha='center',fontsize=10)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/179429344-1f50a179-1cc5-4ba7-8a28-5eecb1b6b436.png" alt="k-mean-cluster" class="center">

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
cluster1 = df2[kmeans.labels_==i].tolist()
            </code></pre>

            <p>Where <code>i</code> is the index of the number of clusters.</p>

            <table>
                <thead>
                    <tr>
                        <th>Clusters</th>
                        <th>States</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1</td>
                        <td>Connecticut, Delaware, Hawaii, Indiana, Kansas, Massachusetts, New Jersey, Ohio, Oklahoma, Oregon, Pennsylvania, Rhode Island, Utah, Virginia, Washington, Wyoming</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Alabama, Arkansas, Georgia, Louisiana, Mississippi, North Carolina, South Carolina, Tennessee</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Alaska, Arizona, California, Colorado, Florida, Illinois, Maryland, Michigan, Missouri, Nevada, New Mexico, New York, Texas</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Idaho, Iowa, Kentucky, Maine, Minnesota, Montana, Nebraska, New Hampshire, North Dakota, South Dakota, Vermont, West Virginia, Wisconsin</td>
                    </tr>
                </tbody>
            </table>

            <br>

            <p>By using this we can determine the intra-cluster distance so that we can interpret the best k value.</p>

            <img src="https://user-images.githubusercontent.com/29410712/179429395-d7ad781a-01ac-493c-8cbf-34d56bd2892a.png" alt="intra-cluster-distance" class="center">

            <p>We can see that the total intra-cluster distance is large for <em>k = 1</em> and decreases as we increase <em>k</em>, until <em>k = 4</em>, after which it tapers off and gets only marginally smaller. The slope becomes constant after <em>k = 4</em>. This indicates that <em>k = 4</em> is a good choice.</p>
            
            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
fig,ax1 = plt.subplots()

ax1.set_xlim(X_PCA[:,0].min()-1,X_PCA[:,0].max()+1)
ax1.set_ylim(X_PCA[:,1].min()-1,X_PCA[:,1].max()+1)

plt.scatter(X_PCA[:, 0], X_PCA[:, 1], c=y_kmeans, s=50)

for i,name in enumerate(df['Unnamed: 0'].values):
    ax1.annotate(name, (X_PCA[i,0], X_PCA[i,1]), ha='center',fontsize=10)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/179429447-e53a4fcb-47c3-4abd-ba4d-a2207156af06.png" alt="kmean-pca" class="center">

            <p>Based on the updated PCA plot with the clustering, it is consistent with the clustering with the points split into four sections.</p>

        </section>

        <br>

        <section id="section-6">

            <h4 id="hierarchical-cluster-analysis"><b>Hierarchical Cluster Analysis</b></h4>

            <p>We will now use hierarchical clustering with complete linkage and Euclidean distance, cluster the states into four clusters. Then we will visualize the cluster results on top of the first two components.</p>
            <p>Hierarchical clustering is often associated with heatmaps. It organizes the rows and columns based on similarity. This makes it easy to see correlations in the data.</p>
            
            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
fig,ax1 = plt.subplots()
agg_cluster_model = AgglomerativeClustering(linkage="complete", affinity='euclidean', n_clusters=4)
y_pred = agg_cluster_model.fit_predict(X)

plt.scatter(X[:, 0], X[:, 1], c=y_pred,  marker="o")

for i,name in enumerate(df['Unnamed: 0'].values):
    ax1.annotate(name, (X[i,0], X[i,1]), ha='center',fontsize=10)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/179429472-2ebf40af-88b6-4f0e-9be7-b01f7e946e4f.png" alt="hierarchical-cluster" class="center">
         
            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
cluster1 = df2[agg_cluster_model.labels_==i].tolist()
            </code></pre>

            <p>Where <code>i</code> is the index of the number of clusters.</p>

            <table>
                <thead>
                    <tr>
                    <th>Clusters</th>
                    <th>States</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                    <td>1</td>
                    <td>Alabama, Alaska, Georgia, Louisiana, Mississippi, North Carolina, South Carolina, Tennessee</td>
                    </tr>
                    <tr>
                    <td>2</td>
                    <td>Arkansas, Connecticut, Delaware, Hawaii, Indiana, Kansas, Kentucky, Massachusetts, Minnesota, Missouri, New Jersey, Ohio, Oklahoma, Oregon, Pennsylvania, Rhode Island, Utah, Virginia, Washington, Wisconsin, Wyoming</td>
                    </tr>
                    <tr>
                    <td>3</td>
                    <td>Arizona, California, Colorado, Florida, Illinois, Maryland, Michigan, Nevada, New Mexico, New York, Texas</td>
                    </tr>
                    <tr>
                    <td>4</td>
                    <td>Idaho, Iowa, Maine, Montana, Nebraska, New Hampshire, North Dakota, South Dakota, Vermont, West Virginia</td>
                    </tr>
                </tbody>
            </table>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
fig,ax1 = plt.subplots()

ax1.set_xlim(X_PCA[:,0].min()-1,X_PCA[:,0].max()+1)
ax1.set_ylim(X_PCA[:,1].min()-1,X_PCA[:,1].max()+1)

plt.scatter(X_PCA[:, 0], X_PCA[:, 1], c=y_pred, s=50)

for i,name in enumerate(df['Unnamed: 0'].values):
    ax1.annotate(name, (X_PCA[i,0], X_PCA[i,1]), ha='center',fontsize=10)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/179429715-5d38e3f6-3d55-480e-be84-0bec4bbf24c3.png" alt="hierarchical-cluster-pca" class="center">

            <p>The results are slightly different from the k-means. The data now is still split into four sections, but some of the states belong in different clusters.</p>
            
        </section>

        <br>

        <section id="section-7">

            <h4 id="dbscan"><b>DBSCAN</b></h4>

            <p>Density-based spatial clustering of applications with noise (DBSCAN) is a data clustering algorithm proposed by Martin Ester, Hans-Peter Kriegel, J√∂rg Sander, and Xiaowei Xu in 1996. It is a density-based clustering non-parametric algorithm: given a set of points in some space, it groups together points that are closely packed together (points with many nearby neighbors), marking as outlier points that lie alone in low-density regions (whose nearest neighbors are too far away).</p>
            
            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
from sklearn.cluster import DBSCAN

db_model = DBSCAN(eps=1, min_samples=2)
db_model.fit(X)
y_pred = db_model.fit_predict(X)

labels = db_model.labels_

n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_noise_ = list(labels).count(-1)
fig,ax1 = plt.subplots()

plt.scatter(X[:, 0], X[:, 1], c=y_pred,  marker="o"); 
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/179429780-cd167133-32a9-4987-b9b0-2ff7eaf1098a.png" alt="dbscan" class="center">
            
            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
cluster1 = df2[db_model.labels_==i].tolist()
            </code></pre>

            <p>Where <code>i</code> is the index of the number of clusters.</p>

            <table>
                <thead>
                    <tr>
                    <th>Clusters</th>
                    <th>States</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                    <td>1</td>
                    <td>Alabama, Georgia, Louisiana, Mississippi, South Carolina, Tennessee</td>
                    </tr>
                    <tr>
                    <td>2</td>
                    <td>Connecticut, Idaho, Indiana, Iowa, Kansas, Kentucky, Maine, Massachusetts, Minnesota, Missouri, Montana, Nebraska, New Hampshire, New Jersey, North Dakota, Ohio, Oklahoma, Oregon, Pennsylvania, Rhode Island, South Dakota, Utah, Vermont, Virginia, Washington, West Virginia, Wisconsin, Wyoming</td>
                    </tr>
                    <tr>
                    <td>3</td>
                    <td>Illinois, New York, Texas</td>
                    </tr>
                    <tr>
                    <td>4</td>
                    <td>Maryland, Michigan, New Mexico</td>
                    </tr>
                </tbody>
            </table>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
fig,ax1 = plt.subplots()

ax1.set_xlim(X_PCA[:,0].min()-1,X_PCA[:,0].max()+1)
ax1.set_ylim(X_PCA[:,1].min()-1,X_PCA[:,1].max()+1)

plt.scatter(X_PCA[:, 0], X_PCA[:, 1], c=y_pred, s=50)

for i,name in enumerate(df['Unnamed: 0'].values):
    ax1.annotate(name, (X_PCA[i,0], X_PCA[i,1]), ha='center',fontsize=10)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/179429796-7dfa95b8-8554-44a6-8259-c27eee4dbeee.png" alt="dbscan-pca" class="center">

            <p>These results on the PCA plot are a lot different than before. The DBSCAN is extremely sensitive to the changes in epsilon in the dataset.</p>
            
        </div>
    </body>

    <footer-component></footer-component>

</html>