<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="icon" type="image/png" sizes="32x32" href="../favicons/favicon.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicons/favicon.png">
        <meta name="theme-color" content="#ffffff">

        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-110543961-1');
        </script>

        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <meta name="description" content="Anthony Do - Portfolio; Machine Learning, Data Analysis">
        <meta name="keywords" content="Machine Learning, Data Analysis">
        <meta name="author" content="Anthony Do">

        <title>Anthony Do</title>

        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/styles.css" rel="stylesheet">

        <script src="https://code.jquery.com/jquery-latest.js" type="text/javascript"></script>
        <script src="../js/jquery.isotope.js" type="text/javascript"></script>
        <script src="../js/filter.js" type="text/javascript"></script>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script src="../js/template.js" type="text/javascript" defer></script>

        <link rel="stylesheet" href="../css/code-highlight.css">
        <script src="../js/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Anthony Do | Data scientist &amp; mathematician knowledgeable in statistical analysis and visualizations to utilize the power of data. &lt;div class=&quot;center&quot;&gt; Resume LinkedIn Profile &lt;/div&gt;</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="Anthony Do" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Data scientist &amp; mathematician knowledgeable in statistical analysis and visualizations to utilize the power of data. &lt;div class=&quot;center&quot;&gt; Resume LinkedIn Profile &lt;/div&gt;" />
<meta property="og:description" content="Data scientist &amp; mathematician knowledgeable in statistical analysis and visualizations to utilize the power of data. &lt;div class=&quot;center&quot;&gt; Resume LinkedIn Profile &lt;/div&gt;" />
<link rel="canonical" href="http://localhost:4000/projects/slc-zillow-analysis.html" />
<meta property="og:url" content="http://localhost:4000/projects/slc-zillow-analysis.html" />
<meta property="og:site_name" content="Anthony Do" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Anthony Do" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Data scientist &amp; mathematician knowledgeable in statistical analysis and visualizations to utilize the power of data. &lt;div class=&quot;center&quot;&gt; Resume LinkedIn Profile &lt;/div&gt;","headline":"Anthony Do","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/profile2.jpg"}},"url":"http://localhost:4000/projects/slc-zillow-analysis.html"}</script>
<!-- End Jekyll SEO tag -->

    </head>

    <body>
        
        <span class="side-btn" id="sideBtn" onclick="toggleNav()">ùêì</span>

        <div class="topnav">
            <portfolio-nav></portfolio-nav>
        </div>
        
        <nav id="mySidenav" class="section-nav">
            <div class="closebtn" onclick="closeNav()">&times;</div>
            <li class="toc">Table of Contents</li>

            <hr style="color: white; border-top: 3px solid white;">
            <ol>
                <li><a href="#section-1">Overview</a></li>
                <li><a href="#section-2">Webscraping Process</a></li>
                <li><a href="#section-3">Preliminary Analysis</a></li>
                <li><a href="#section-4">GeoSpatial Analysis</a></li>
                <li><a href="#section-5">Linear Regression</a></li>
                <li><a href="#section-6">Machine Learning Algorithms</a>
                    <ul>
                        <li><a href="#section-7">Principal Component</a></li>
                        <li><a href="#section-8">K-Means Clustering</a></li>
                        <li><a href="#section-9">Hierarchical Clustering</a></li>
                    </ul>
                </li>
            </ol>
        </nav>

        <div class="container">

            <br>
            <br>
            <br>

            <script src="../js/load-mathjax.js" async></script>

            <section id="section-1">

            <h1 id="salt-lake-county-real-estate-analysis"><b>Salt Lake County Real Estate Analysis</b></h1>

            <hr>

            <p>We will be analyzing real estate data from different cities in the Salt Lake County listed as of November 2022. In this project, we will be scraping <a href="https://www.zillow.com">Zillow</a>, an American tech real-estate marketplace company. Zillow is one of the most popular real estate sites because offers the most robust suite of tools for home professionals and it sources postings from both the MLS (Multiple Listing Services) and non-MLS sources. Non-MLS sources include for sale by owner, non-MLS foreclosures, and auctions. Additionally, Zillow has the largest database of over 135 million properties. </p>
            <p>After gathering the data, we will create different visualizations with geospatial analysis and charts to uncover preliminary trends between different variables. We will also be using linear regressions and different unsupervised machine learning algorithms such as Principal Component Analysis and K-Means Clustering to gain meaningful insights in the data we collected.</p>

            <br>

            <h4 id="resources"><b>Resources</b></h4>

            <ul>
                <li>Software: Python 3.10, Jupyter Lab 3.4.4</li>
                <li>Data Source: ZillowData.csv - <a href="https://www.zillow.com">Zillow.com</a></li>
            </ul>

        </section>

        <br>

        <section id="section-2">

            <h2 id="webscraping-process"><b>Webscraping Process</b></h2>

            <hr>

            <h4><b>Scrape Zillow using BeautifulSoup</b></h4>

            <p>BeautifulSoup is a Python package for parsing HTML and XML documents. It creates a parse tree for parsed pages that can be used to extract data from HTML, which is useful for web scraping. We will be scraping data from different cities in the Salt Lake County from Zillow. We avoided any problems with Zillow blocking us from downloading the data by saving all the HTML files in the data folder. The path to the data folder is stored in the <code>DATA_PATH</code> variable. Furthermore, the <code>ZillowData</code> folder contains the HTML source code for the different cities. The file name contains the city name with the corresponding page number from Zillow:</p>

            <center>
                <table>
                    <tbody>
                        <tr>
                            <td><code>wvc1.html</code></td>
                            <td><code>draper1.html</code></td>
                            <td> ... </td>
                            <td><code>slc1.html</code></td>
                        </tr>
                        <tr>
                            <td><code>wvc2.html</code></td>
                            <td><code>draper2.html</code></td>
                            <td> ... </td>
                            <td><code>slc2.html</code></td>
                        </tr>
                        <tr>
                            <td><code>wvc3.html</code></td>
                            <td><code>draper3.html</code></td>
                            <td> ... </td>
                            <td><code>slc3.html</code></td>
                        </tr>
                    </tbody>
                </table>
            </center>

            <br>

            <h4><b>The Data</b></h4>

            <p>We were able to scrape 14 different variables associated with each of the 2,107 properties in this dataset. The data selection, processing, and transformation Python code can be viewed in the <code>ZillowUT_Data.ipynb</code> file and the cleaned data can be viewed in the <code>ZillowData.csv</code> file.</p>
            <p>We also checked the data types and converted any numbers that were read as strings to numerical values. In particular, we converted <code>type</code> into a piecewise function where <code>proptype</code> takes a binary form of 0 or 1. That is:</p>

            $$
            \text{proptype} =
            \begin{cases}
                0,  &amp; \text{condo/townhouse/lot} \\
                1, &amp; \text{single family house}
            \end{cases}
            $$

            <p>Finally, we replaced all null values in <code>beds</code> and <code>baths</code> with 0 and removed all listings with erroneous <code>longitude</code> and <code>latitude</code> missing values.</p>

            <br>

            <h4 id="removing-outliers"><b>Removing Outliers</b></h4>

            <p>From the scatterplot below, we can see that the cities: Holladay, Salt Lake City, Sandy, South Jordan, West Jordan, and Draper have problematic outliers.</p>

            <br>

            <img src="https://user-images.githubusercontent.com/29410712/203437983-866847a3-791b-495d-a30c-2f6f8eb177c2.png" alt="BC Home Price Scatter" class="center">

            <br>

                <p>To remove these outliers, we calculated the interquartile range to decipher the outlier cutoff. </p>

            $$
            IQR = Q_3 - Q_1
            $$

            <p>
                The outlier cutoff is the interquartile range times by 1.5 and subtracted from the lower and upper bounds. The data points that are above the upper bound and below the lower bound this cutoff will be removed to get a more precise analysis without outliers.
                Here is an example of how we removed the outliers of each city.
            </p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
# # Salt Lake City Box Plot
outlier = df.loc[df["city"] == "Salt Lake City"]
outlier = outlier['price']

# Remove Salt Lake City Outliers
# Calculate interquartile range
q25, q75 = np.percentile(outlier, 25), np.percentile(outlier, 75)
iqr = q75 - q25

# Calculate the outlier cutoff
cut_off = iqr * 1.5
lower, upper = q25 - cut_off, q75 + cut_off

# Identify outliers
outliers = [x for x in outlier if x < lower or x > upper]

# Remove outliers
df = df.drop(df[(df['city'] == 'Salt Lake City') & (df['price'] < lower)].index)
df = df.drop(df[(df['city'] == 'Salt Lake City') & (df['price'] > upper)].index)
            </code></pre>

            <p>The second scatterplot illustrates the data without the outliers:</p>

            <img src="https://user-images.githubusercontent.com/29410712/203438013-477acca7-14af-401b-9a20-12426841631b.png" alt="AC Home Price Scatter" class="center">

        </section>

        <br>

        <section id="section-3">

            <h2 id="preliminary-analysis"><b>Preliminary Analysis</b></h2>

            <hr>

            <img src="https://user-images.githubusercontent.com/29410712/203438049-2fc3e8a7-fe2e-4c4c-8921-d3230ef28a60.png" alt="Average Home Price" class="center">

            <p>From the chart above, the cities with the highest average home prices are Draper and Holladay. The cities with the lowest average home prices are Kearns and Millcreek. Additionally, the chart remains relatively the same with the average home sqft. The cities with the highest average home sqft are Draper and Herriman and the cities with the lowest average home sqft are still Kearns and Millcreek. This could potentially be explained by the locations of the cities which is explained later in the analysis.</p>

            <img src="https://user-images.githubusercontent.com/29410712/203438068-30c12759-5a14-41c8-b1fb-6ea28cf2b017.png" alt="Average Home Sqft" class="center">

            <p>However, the order of the cities change dramatically based on the average cost per sqft. From the chart below, we can see that the cities with the highest average cost per sqft are Millcreek and Holladay and the cities with the lowest average cost per sqft are West Valley City and Bluffdale.</p>

            <img src="https://user-images.githubusercontent.com/29410712/203438080-9312a3ef-892d-4ed4-8ad2-20b6e3e62d98.png" alt="Average Cost per Sqft" class="center">
            
            <p>We also looked into the correlation between the list price of the homes and the sqft. Based on the scatterplot generated, we can visualize the positive correlation between price and sqft. This means that as the sqft of the homes increase, the prices also increase.</p>

            <img src="https://user-images.githubusercontent.com/29410712/203019394-f2f98c0b-1106-4eb8-9ff6-4a7f75567acb.png" alt="Price vs Sqft Scatterplot" class="center">

        </section>

        <br>

        <section id="section-4">

            <h2 id="geospatial-analysis"><b>GeoSpatial Analysis</b></h2>

            <hr>

            <img src="https://user-images.githubusercontent.com/29410712/203144090-4bd1d62c-f755-4d2d-8b90-1aa00e17cedc.png" alt="saltlake" class="center image70">

            <br>

            <p>Geospatial data defines specific geographical locations, either in the form of latitude and longitude coordinates or text fields with names of geographical areas, such as countries or states. Geospatial charts combine geospatial data with other forms of data to create map-based charts. Our geodata contains (x, y) coordinates of geographical locations. The geometric shapes in a GeoSeries or GeoDataFrame object are simply a collection of coordinates in an arbitrary space. The Coordinate Reference System (CRS) tells Python how those coordinates relate to places on the Earth and is used to project the location coordinates onto a map for visualization. We will use the WGS84 latitude-longitude projection. </p>
            <p>We will use two of the variables, latitude and longitude, of each listing to visualize the data of Salt Lake County with GeoPandas, a high-level interface Python library for making maps. This can be referred by using the authority code <code>EPSG:4326</code>.</p>
            
            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
crs = 'EPSG:4326'
geometry = [Point(xy) for xy in zip(df['longitude'], df['latitude'])]
geo_df = gpd.GeoDataFrame(df, crs = crs, geometry = geometry)
            </code></pre>

            <p>We then created heat maps showcasing the distribution of property prices and sqft:</p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
geo_df['price_log'] = np.log(geo_df['price'])
fig, ax = plt.subplots(figsize = (10,10))
utah_map.to_crs(epsg=4326).plot(ax=ax, color='lightgrey')
geo_df.plot(column = 'price_log', ax=ax, cmap = 'inferno',
            legend = True, legend_kwds={'shrink': 0.5}, markersize = 15)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/203021376-8a353e56-80d3-4256-b7b1-59b43c6901c6.png" alt="Price Heat Map" class="center">

            <p>From the price heat map of Salt Lake County, we can see that a majority of the higher priced real estate properties are located on the east side of the Salt Lake valley. This corresponds with our previous analysis since Draper and Holladay are located in this area. Additionally, lower priced homes are located on the west side of Salt Lake City.</p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
geo_df['sqft_log'] = np.log(geo_df['sqft'])
fig, ax = plt.subplots(figsize = (10,10))
utah_map.to_crs(epsg=4326).plot(ax=ax, color='lightgrey')
geo_df.plot(column = 'sqft_log', ax=ax, cmap = 'inferno',
            legend = True, legend_kwds={'shrink': 0.5},
            alpha = .5)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/203021397-f9a790c7-c4cd-484c-9062-64cfc847c19e.png" alt="Sqft Heat Map" class="center">

            <p>In the sqft heat map of Salt Lake County, we can see that the real estate properties with more square feet are located on the east and south-west sides of the Salt Lake Valley which is understandable since the locations are further away from the city center.</p>

        </section>

        <br>

        <section id="section-5">

            <h2 id="linear-regression"><b>Linear Regression</b></h2>

            <hr>

            <h4 id="ordinary-least-squares-assumptions-"><b>Ordinary Least Squares Assumptions:</b></h4>

            <ol>
                <li>Standard Errors assume that the covariance matrix of the errors is correctly specified.</li>
                <li>The condition number is large, 1.22e+03. This might indicate that there are strong multicollinearity or other numerical problems.</li>
                <li>The linear regression model is ‚Äúlinear in parameters.‚Äù</li>
                <li>There is a random sampling of observations.</li>
                <li>There is homoscedasticity and no autocorrelation.</li>
            </ol>

            <p>We now develop a multilinear regression model for real estate property prices in the Salt Lake County. We could use this to come up with a price for properties coming on the market. Our model is now in the form:</p>

            $$
            Y = Œ≤_0 + Œ≤_1x_1 + Œ≤_2x_2 + \cdots + Œ≤_nx_n + Œµ
            $$

            <p>where $x_n$ are predictive variables.</p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
mod = sm.ols(formula="price ~ sqft + beds + baths + proptype", data = df)
res = mod.fit()
            </code></pre>

            <blockquote>
                <p>Output:</p>
            </blockquote>

            <pre><code class="nohighlight">                            
                            OLS Regression Results                            
==============================================================================
Dep. Variable:                  price   R-squared:                       0.640
Model:                            OLS   Adj. R-squared:                  0.639
Method:                 Least Squares   F-statistic:                     872.9
Date:                Mon, 21 Nov 2022   Prob (F-statistic):               0.00
Time:                        02:36:54   Log-Likelihood:                -26554.
No. Observations:                1972   AIC:                         5.312e+04
Df Residuals:                    1967   BIC:                         5.315e+04
Df Model:                           4                                         
Covariance Type:            nonrobust                                         
==============================================================================
                  coef    std err          t      P>t|      [0.025      0.975]
------------------------------------------------------------------------------
Intercept   1.024e+05   1.28e+04     7.974      0.000    7.72e+04    1.28e+05
sqft         180.8805      5.669     31.907      0.000     169.763     191.998
beds       -8116.8371   3965.622     -2.047      0.041   -1.59e+04    -339.575
baths       2.722e+04   5920.118      4.598      0.000    1.56e+04   3.88e+04
proptype    4.042e+04   9865.190      4.097      0.000    2.11e+04    5.98e+04
==============================================================================
Omnibus:                      882.045   Durbin-Watson:                   1.447
Prob(Omnibus):                  0.000   Jarque-Bera (JB):             7474.571
Skew:                           1.898   Prob(JB):                         0.00
Kurtosis:                      11.750   Cond. No.                     9.78e+03
==============================================================================
            </code></pre>

            <p>In the multiple linear regression model, the intercept of the regression is 102,400 and the R-squared is 0.640. The R-squared is the proportion of the variation in the dependent variable that is predictable from the independent variable. This means that around 64.0% of the variability observed in the target variable is explained by this regression model. Additionally, all the variables are statistically significant at an alpha of 5% and can be used to predict the listed price of the real estate property. With further clarification, as the sqft of the real estate property and the number of baths increase by one, the price increases by 181 and 27220, respectively. Moreover, as the number of bedrooms increase by one, the price actually decreases by 8116. We can also see that if the real estate property is a Single Family Home, it increases the price of the property. </p>

        </section>

        <br>

        <section id="section-6">

            <h2 id="machine-learning-algorithms-deeper-analysis-"><b>Machine Learning Algorithms (Deeper Analysis)</b></h2>

            <hr>

            <p>For this analysis, we will be using Principal Component Analysis, K-Means Clustering, and Hierarchical Clustering to understand how the prices, sqft, and cost per sqft differ between zipcodes.</p>

        <br>

        <section id="section-7">

            <h4 id="principal-component-analysis-pca-"><b>Principal Component Analysis (PCA)</b></h4>

            <p>Principal Component Analysis (PCA) is one of the most used unsupervised machine learning algorithms across a variety of applications: exploratory data analysis, dimensionality reduction, information compression, and data de-noising. PCA is a dimensionality reduction technique that transforms a set of features in a dataset into a smaller number of features called principal components while at the same time trying to retain as much information in the original dataset as possible. Since we have 3 different variables, we have a three-dimensional data set. PCA can take 4 or more variables and make a two-dimensional PCA plot. PCA can also tell us which variable is the most valuable for clustering the data. It also can tell us how accurate the two-dimensional graph is.</p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">  
from sklearn.decomposition import PCA

pca_model = PCA(n_components=3)
X_PCA = pca_model.fit_transform(X)
df_plot = pd.DataFrame(X_PCA, columns=['PC1', 'PC2', 'PC3'])
df_plot.head()
fig,ax1 = plt.subplots(figsize=(10, 6))

ax1.set_xlim(X_PCA[:,0].min()-1,X_PCA[:,0].max()+1)
ax1.set_ylim(X_PCA[:,1].min()-1,X_PCA[:,1].max()+1)

for i,name in enumerate(summary['zipcode'].values):
    ax1.annotate(name, (X_PCA[i,0], X_PCA[i,1]), ha='center',fontsize=10)
            </code></pre>

            <p>Principal Component Analysis calculates the average of each variable and using this average, finds the center of the data. It then shifts the data so that the center of the data is at the origin. From here, we input principal components. The principal components are vectors, but they are not chosen at random. The first principal component (PC1) is computed so that it explains the greatest amount of variance in the original features. Thus, it minimizes the distance between each data point on the graph (Sum of Squared) so PC1 is a linear combination of variables. </p>
            <p>In order to maximize variance, the first weight vector $w_{(1)}$ thus has to satisfy:</p>

            $$
                
            \begin{aligned}
            w_{(1)} &= \text{arg } \displaystyle{\max_{||w|| = 1}} \left( \sum_{i} {(t_1)}^2_{(i)} \right) \\
            &= \text{arg } \displaystyle{\max_{||w|| = 1}} \left( \sum_{i} {(x_{(i)} * w)}^2 \right)
            \end{aligned}
                
            $$

            <p>Since $w_{(1)}$ has been defined to be a unit vector, it equivalently also satisfies:</p>

            $$
            w_{(1)} = \text{arg max} \left( \frac{w^TX^TXw}{w^Tw} \right)
            $$

            <p>The quantity to be maximized can be recognized as a Rayleigh quotient. A standard result for a positive semidefinite matrix such as $X^TX$ is that the quotient&#39;s maximum possible value is the largest eigenvalue of the matrix, which occurs when $w$ is the corresponding eigenvector.</p>
            <p>In our analysis, we require more than one component. The $k^{th}$ component can be found by subtracting the first $k ‚àí 1$ principal components from $X$ and then finding the weight vector which extracts the maximum variance from this new data matrix:</p>

            $$
            \hat X_k = X - \sum_{s=1}^{k-1}{Xw_{(s)}w_{(s)}^T}
            $$

            $$
                \begin{aligned}
                w_{(k)} &= \text{arg } \displaystyle{\max_{||w|| = 1}} \left( ||\hat X_{k}w||^2 \right) \\
                &= \text{arg max} \left( \frac{w^T\hat X_k^T\hat X_kw}{w^Tw} \right)
            \end{aligned}
            $$

            <p>The sum of squared distances for the best fit line is the eigenvalue for PC1. The second component (PC2) is orthogonal to the first, and it explains the greatest amount of variance left after the first principal component. Then we find PC3 which is perpendicular to PC1 and PC2. The number of PCs is either the number of variables or the number of samples, whichever is smaller.</p>

            <img src="https://user-images.githubusercontent.com/29410712/203155568-68b4015c-9f68-4087-bbb6-0a44f0228fe0.png" alt="PCA" class="center">

            <p>Once all the principal components are figured out, you can use the eigenvalues to determine the proportion of variation that each PC accounts for. Then you can create a scree plot which is a graphical representation of the percentages of variation that each PC accounts for.</p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
var_ratio = pca_model.explained_variance_ratio_

fig,ax1 = plt.subplots(figsize=(10, 6))
plt.plot([1,2,3], var_ratio, '-o')
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/203187782-514206c0-9198-4339-8c68-f7837bd136a8.png" alt="scree-plot" class="center">

            <p>In this scree plot, we can see that PC1 and PC2 account for the vast majority of the variation. This means that a two-dimensional graph, using just PC1 and PC2 would be a good approximation of this three-dimensional graph since it would account for 99.22% of the variation in the data. Also, a one-dimensional graph would account for 59.98% of the variation in the data.</p>

            <blockquote>
                <p>Output:</p>
            </blockquote>

            <pre><code class="nohighlight">
Explained Variance Ratios of the PCA: [0.59977592 0.39255202 0.00767206]
            </code></pre>

        </section>

        <br>

        <section id="section-8">

            <h4 id="k-means-cluster-analysis"><b>K-Means Cluster Analysis</b></h4>

            <p>K-means cluster identifies initial clusters and calculates the variances between each cluster or the Euclidean distance. It clusters all the remaining points, calculates the mean of each cluster, and then reclusters based on the new means. It repeats until the clusters no longer change. It restarts the cluster until it finds the best overall cluster. It does as much reclustering as we tell it to do. It then comes back and returns to the optimal one.</p>

            <img src="https://user-images.githubusercontent.com/29410712/203158939-fde4b778-24a9-4949-b8a5-51a517d1fded.png" alt="Different K-Means" class="center image">

            <br>

            <p>First, we need to determine the best K value. An easy method for determining the best number for K is the elbow curve. To create an elbow curve, we&#39;ll plot the clusters on the x-axis and the values of a selected objective function on the y-axis. The intra-cluster distance is one of the most common objective functions to use when creating an elbow curve. The intra-cluster distance objective function is measuring the amount of variation in the dataset. For our elbow curve, we will plot the number of clusters (also known as the values of K) on the x-axis and the total intra-cluster distance values on the y-axis.</p>

            <img src="https://user-images.githubusercontent.com/29410712/203158951-caf2a648-746a-4908-9cd1-a423b225d669.png" alt="Intra-Cluster-Distance" class="center">

            <p>Using the "elbow" or "knee of a curve" as a cutoff point is a common heuristic in mathematical optimization to choose a point where diminishing returns are no longer worth the additional cost. In clustering, this means one should choose several clusters so that adding another cluster doesn't result in a better model. The intuition is that increasing the number of clusters will naturally improve the fit (explain more of the variation) since there are more parameters (more clusters) to use, but at some point this is over-fitting, and the elbow reflects this. We can see that the total intra-cluster distance is large for k = 1 and decreases as we increase k, until k = 6, after which it tapers off and gets only marginally smaller. The slope becomes constant after k = 6. This indicates that k = 6 is a good choice. Therefore, will now cluster the states into six clusters using K-means. </p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
kmeans = KMeans(n_clusters=6)
kmeans.fit(X)
y_kmeans = kmeans.predict(X)
fig,ax1 = plt.subplots(figsize=(10, 6))

plt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50)

for i,name in enumerate(summary['zipcode'].values):
    ax1.annotate(name, (X[i,0], X[i,1]), ha='center',fontsize=10)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/203157630-3e2f35b9-9fe7-4717-bb06-4335d841c807.png" alt="K-Mean" class="center">

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
df2 = summary['zipcode'].values
cluster1 = df2[kmeans.labels_==i].tolist()
            </code></pre>

            <p>Where <code>i</code> is the index of the number of clusters.</p>

            <center>
                <table>
                <thead>
                <tr>
                <th>Clusters</th>
                <th>Zipcodes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                <td>1</td>
                <td>84107, 84116, 84118, 84104, 84119, 84123</td>
                </tr>
                <tr>
                <td>2</td>
                <td>84020, 84092, 84121, 84093, 84095, 84065, 84096</td>
                </tr>
                <tr>
                <td>3</td>
                <td>84009, 84094, 84088, 84081, 84084, 84047, 84128, 84120, 84070, 84044, 84129</td>
                </tr>
                <tr>
                <td>4</td>
                <td>84101, 84111</td>
                </tr>
                <tr>
                <td>5</td>
                <td>84105, 84108, 84117, 84109, 84124, 84103</td>
                </tr>
                <tr>
                <td>6</td>
                <td>84106, 84102, 84115</td>
                </tr>
                </tbody>
                </table>
            </center>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
from pandas.plotting import parallel_coordinates

palette = sns.color_palette("Set1", 10)
X_df = summary.drop(['zipcode'],axis=1)
    
def display_parallel_coordinates_centroids(df, num_clusters):
    '''Display a parallel coordinates plot for the centroids in df'''
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/203230763-3f7b53a7-0beb-4a16-b3a3-b30b769d4041.png" alt="Parallel-Centroids" class="center">

            <p>From the Parallel Coordinates Centroids plot, we can see the variation across the variables for each of the clusters found by the K-means algorithm. We can identify that the real estate properties located in the Cluster 4 zip codes have relatively low average sqft but high cost per sqft and the Cluster 2 zip codes have high average prices and high average sqft.</p>

            <br>

            <h4 id="k-means-clustering-with-principal-component-analysis"><b>K-Means Clustering with Principal Component Analysis</b></h4>

            <p>Applying the K-means to the Principal Component Analysis projection data produces an additional categorical constraint to validate the clustering algorithm. In other words, we can use dimensionality reduction as a feature extractor and reveal the different clusters. Based on the updated PCA plot with the clustering, it is consistent with the clustering with the points split into six sections:</p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
fig,ax1 = plt.subplots(figsize=(10, 6))

ax1.set_xlim(X_PCA[:,0].min()-1,X_PCA[:,0].max()+1)
ax1.set_ylim(X_PCA[:,1].min()-1,X_PCA[:,1].max()+1)

plt.scatter(X_PCA[:, 0], X_PCA[:, 1], c=y_kmeans, s=50)

for i,name in enumerate(summary['zipcode'].values):
    ax1.annotate(name, (X_PCA[i,0], X_PCA[i,1]), ha='center',fontsize=10)
            </code></pre>
            
            <img src="https://user-images.githubusercontent.com/29410712/203165056-6b1c828b-6dcc-492f-b01e-61d6f91e2077.png" alt="K-Mean-PCA" class="center">

        </section>

        <br>

        <section id="section-9">

            <h4 id="hierarchical-cluster-analysis"><b>Hierarchical Cluster Analysis</b></h4>

            <p>Similar to K-means clustering, hierarchical clustering, also known as agglomerative clustering, works with groups (clusters) of data points. The algorithm starts by declaring each point with its own cluster, then merges the two most similar clusters until a declared stopping point has been reached. Hierarchical clustering is often associated with heatmaps and organizes the rows and columns based on similarity. This makes it easy to see correlations in the data.</p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
ff.create_dendrogram(X_PCA, color_threshold=0, labels=summary['zipcode'].values)
            </code></pre>
            
            <img src="https://user-images.githubusercontent.com/29410712/203176302-a42e2a89-f66e-4ade-809a-0b36ba9f99f4.png" alt="dendogram" class="center">

            <br>

            <p>Additionally, we created a dendogram to know how many clusters to make. A dendrogram is a graph that keeps the values of the points on the x-axis, then connects all the points as they are clustered. This is similar to the elbow curve, as it gives us a better idea of the ideal amount of clusters we want to use. Based on the dendogram above, we will now use hierarchical clustering with complete linkage and Euclidean distance to sort the zipcodes into six clusters. </p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
from sklearn.cluster import AgglomerativeClustering

fig,ax1 = plt.subplots(figsize=(10, 6))
agg_cluster_model = AgglomerativeClustering(linkage="complete", affinity='euclidean', n_clusters=6)
y_pred = agg_cluster_model.fit_predict(X)

plt.scatter(X[:, 0], X[:, 1], c=y_pred,  marker="o")
for i,name in enumerate(summary['zipcode'].values):
    ax1.annotate(name, (X[i,0], X[i,1]), ha='center',fontsize=10)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/203176736-5c797f25-067d-4624-b98f-dbac6299a9b9.png" alt="Hierarchical" class="center">

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
df2 = summary['zipcode'].values
cluster1 = df2[agg_cluster_model.labels_==i].tolist()
            </code></pre>

            <p>Where <code>i</code> is the index of the number of clusters.</p>

            <center>
                <table>
                    <thead>
                        <tr>
                        <th>Clusters</th>
                        <th>Zipcodes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <td>1</td>
                        <td>84020, 84092, 84121, 84093, 84095, 84065, 84109, 84096</td>
                        </tr>
                        <tr>
                        <td>2</td>
                        <td>84009, 84094, 84088, 84081, 84084, 84047, 84128, 84120, 84070, 84044, 84129</td>
                        </tr>
                        <tr>
                        <td>3</td>
                        <td>84106, 84102, 84115</td>
                        </tr>
                        <tr>
                        <td>4</td>
                        <td>84101, 84111</td>
                        </tr>
                        <tr>
                        <td>5</td>
                        <td>84105, 84108, 84117, 84124, 84103</td>
                        </tr>
                        <tr>
                        <td>6</td>
                        <td>84107, 84116, 84118, 84104, 84119, 84123</td>
                        </tr>
                    </tbody>
                </table>
            </center>

            <br>

            <h4 id="hierarchical-clustering-with-principal-component-analysis"><b>Hierarchical Clustering with Principal Component Analysis</b></h4>

            <p>Applying the Hierarchical Clustering to the Principal Component Analysis projection data produces an additional categorical constraint to validate the clustering algorithm. In other words, we can use dimensionality reduction as a feature extractor and reveal the different clusters. Based on the updated PCA plot with the clustering, it is consistent with the clustering with the points split into six sections:</p>

            <blockquote>
                <p>Python Code:</p>
            </blockquote>

            <pre><code class="language-python">
fig,ax1 = plt.subplots(figsize=(10, 6))

ax1.set_xlim(X_PCA[:,0].min()-1,X_PCA[:,0].max()+1)
ax1.set_ylim(X_PCA[:,1].min()-1,X_PCA[:,1].max()+1)

plt.scatter(X_PCA[:, 0], X_PCA[:, 1], c=y_pred, s=50)

for i,name in enumerate(summary['zipcode'].values):
    ax1.annotate(name, (X_PCA[i,0], X_PCA[i,1]), ha='center',fontsize=10)
            </code></pre>

            <img src="https://user-images.githubusercontent.com/29410712/203176836-ca08d232-3bc9-4626-bfae-3cbb8d0ee762.png" alt="Hierarchical-PCA" class="center">

        </section>
        </div>
    </body>

    <footer-component></footer-component>
    
</html>

